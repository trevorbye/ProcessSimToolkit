# ProcessSimToolkit

This is a simplified tool for running stochastic discrete-event process simulations that follow a Server/Queue model. Models are easily built in a building-block format, with easy access to the classes and functions to create custom logic for more-complicated scenarios. Plotting output is included for a histogram output of total system time, as well as live plotting for output mean stabilization used for determining optimal simulation runs. 

<br><br>
## Lemonade Stand Tutorial

Full code for this tutorial can be accessed [here.](https://github.com/trevorbye/ProcessSimToolkit/blob/master/LemonadeStandTutorial/LemonadeStandSim.py)
<br><br>

### Getting Started

This is a tutorial for simulating the flow of customers through a lemonade stand. Although a simple example, it serves to illustrate the design pattern for this toolkit, and simply adding more Servers/Queues will allow for significantly more complex simulations. To get started, fork this entire project.

After you have access to all classes, begin by importing the necesary libraries and classes:

```python
from UtilityClasses.ServerEntity import Server
from UtilityClasses.QueueEntity import PriorityQueue
from UtilityClasses.TimeRandomizerEntity import TimeRandomizer
from UtilityClasses.ServerAndQueueWrapperEntity import ServerAndQueueWrapper
from SimulationClasses.SimulationApplication import SimApplication

import datetime
```
<br>

The `UtilityClasses` are various classes used as the building blocks for building a simulation. The `Server` class represents a capacity-constrained resource in your system that processes customers and holds them for a certain period of time. This time is stochastically generated by the `TimeRandomizer` class, which allows you to define different distributions to draw samples from. After customers are processed by a server, they are typically transitioned into a `PriorityQueue` where wait time is accumulated while waiting for the next server to be available (in this tutorial there is only one server for brevity). `ServerAndQueueWrapper` is simply a wrapper object for either a `Server` or a `PriorityQueue`, and allows all system resources to be added to one list in sequence. `SimApplication` is the main configuration class, and accepts parameters for the start and end time of each run, total simulation runs, and switches for turning on/off chart output. Importing `datetime` is necesary to define these time parameters.

<br>

### Building the System

Begin by defining an empty list, which will hold all `Server` and `PriorityQueue` objects we will build. Note: this list represents the sequence of events in the simulation, thus objects must be added in order of occurence within the system.

```python
server_queue_wrapper_list = []
```

<br><br>

Next we will begin building the logic that stochastically introduces customers into the system. First, we must define a `TimeRandomizer` object that will determine the distribution and it's parameters used for this sampling. In this case, we will use a normal distribution and state that customers arrive to the lemonade stand with a mean of every 20 seconds and a standard deviation of 5 seconds:

```python
arrival_time_randomizer = TimeRandomizer("normal", normal_mean=20, normal_stddev=5)
```
<br><br>

After defining the randomizer, we will build the arrival server. The first parameter is capacity for the server, and must always be 1 for an arrival server. The second parameter is an object of type `TimeRandomizer`, which we have defined as `arrival_time_randomizer`. The third parameter is an optional text description for the server.

```python
arrival_server = Server(1, arrival_time_randomizer, description="Arrival Server")
```
<br><br>

Now that the server object is built, wrap it in a `ServerAndQueueWrapper` object and add it to `server_queue_wrapper_list`:

```python
arrival_wrapper = ServerAndQueueWrapper(server_object=arrival_server)
server_queue_wrapper_list.append(arrival_wrapper)
```





